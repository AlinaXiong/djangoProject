def batch_insert(self, cursor, records, prefix):
    """
    Insert a batch of parsed log records into the database at one time,
    using Oracle's batch error feature to handle conflicts in a single pass.
    """
    if not records:
        return

    # 根据 prefix 决定表名的逻辑保持不变
    if "PROD" in prefix:
        insert_sql = """
            INSERT INTO dsp_query_client_logs_prod
            (
                client_name, client_ip, server_name, environment, cache_name, region_name,
                location, log_time, query_oql, app_id, data_source, type_field, target_field,
                oql_size, duration, hint, success, process_time
            )
            VALUES
            (
                :client_name, :client_ip, :server_name, :environment, :cache_name, :region_name,
                :location, TO_TIMESTAMP(:log_time, 'YYYY-MM-DD HH24:MI:SS'), :query_oql, :app_id,
                :data_source, :type_field, :target_field, :oql_size, :duration, :hint, :success,
                TO_TIMESTAMP(:process_time, 'YYYY-MM-DD HH24:MI:SS')
            )
        """
    else:
        insert_sql = """
            INSERT INTO dsp_query_client_logs
            (
                client_name, client_ip, server_name, environment, cache_name, region_name,
                location, log_time, query_oql, app_id, data_source, type_field, target_field,
                oql_size, duration, hint, success, process_time
            )
            VALUES
            (
                :client_name, :client_ip, :server_name, :environment, :cache_name, :region_name,
                :location, TO_TIMESTAMP(:log_time, 'YYYY-MM-DD HH24:MI:SS'), :query_oql, :app_id,
                :data_source, :type_field, :target_field, :oql_size, :duration, :hint, :success,
                TO_TIMESTAMP(:process_time, 'YYYY-MM-DD HH24:MI:SS')
            )
        """

    try:
        # --- 1) 批量插入 + batcherrors=True 开启批量错误模式 ---
        #    注意：batcherrors=True 需要 Oracle 驱动支持，如 python-oracledb、cx_Oracle等
        cursor.executemany(insert_sql, records, batcherrors=True)
        
        # --- 2) 收集所有 batch error ---
        batch_errors = cursor.getbatcherrors()
        
        # 统计重复行和其他错误行
        duplicates_count = 0
        other_errors_count = 0
        
        for error in batch_errors:
            # error.offset 是在当前 batch 中出错的第几行
            # error.message 是数据库返回的错误信息
            err_msg = str(error.message).upper()
            if "ORA-00001" in err_msg or "UNIQUE CONSTRAINT" in err_msg:
                # 说明是唯一键冲突
                duplicates_count += 1
            else:
                # 其他错误（比如数据类型不匹配等）
                other_errors_count += 1
                self.logger.error(
                    f"Row offset {error.offset} failed with error: {error.message}"
                )

        # --- 3) 成功行数 = 总行数 - 冲突行数 - 其他错误行数 ---
        success_count = len(records) - duplicates_count - other_errors_count

        # 在 batch error 模式下，Oracle 会插入所有能插入的行，只有出错的行被忽略或回滚
        # 因此此时需要你决定：commit 还是 rollback
        # 常见做法是 commit 成功部分，然后对冲突行做汇总日志
        cursor.connection.commit()

        # 只打一条汇总日志
        if other_errors_count == 0:
            self.logger.info(
                f"Batch inserted {success_count} records; ignored {duplicates_count} duplicates."
            )
        else:
            self.logger.warning(
                f"Batch inserted {success_count} records; ignored {duplicates_count} duplicates; "
                f"{other_errors_count} rows had other errors (check logs)."
            )

    except Exception as e:
        # 如果出现非批量错误模式可处理的情况或驱动不支持等，就走这里
        self.logger.error(f"Error inserting data with batch error mode: {e}", exc_info=True)
        raise
